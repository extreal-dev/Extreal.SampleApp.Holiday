import{io as e}from"socket.io-client";import{isAsync as s,addAction as t,callback as i}from"@extreal-dev/extreal.integration.web.common";class c{constructor(e){this.finishIceCandidateGathering=()=>{this.isIceCandidateGatheringFinished=!0,this.fireOnStarted()},this.finishOfferAnswerProcess=()=>{this.isOfferAnswerProcessFinished=!0,this.fireOnStarted()},this.fireOnStarted=()=>{this.isIceCandidateGatheringFinished&&this.isOfferAnswerProcessFinished&&this.onStarted()},this.clear=()=>{this.isIceCandidateGatheringFinished=!1,this.isOfferAnswerProcessFinished=!1},this.onStarted=e,this.isIceCandidateGatheringFinished=!1,this.isOfferAnswerProcessFinished=!1}}const n={None:0,Host:1,Client:2};class o{constructor(t,i){this.addPcCreateHook=e=>{this.pcCreateHooks.push(e)},this.addPcCloseHook=e=>{this.pcCloseHooks.push(e)},this.getSocket=()=>{if(null!==this.socket){if(this.socket.connected)return this.socket;this.stopSocket()}const s=e(this.peerConfig.url,this.peerConfig.socketOptions);return this.socket=s,this.socket.on("connect",(()=>{this.isDebug&&console.log(`Socket connected: id=${s.id}`)})),this.socket.on("message",this.receiveMessageAsync),this.socket.on("user disconnected",this.receiveUserDisconnected),this.socket.on("connect_error",this.receiveConnectError),this.socket.on("disconnect",this.receiveDisconnect),this.socket.connect(),this.socket},this.receiveMessageAsync=async e=>{this.isDebug&&console.log(`Receive message: ${JSON.stringify(e)}`);const s=this.getFrom(e);switch(e.type){case"join":await this.receiveJoinAsync(s);break;case"call me":await this.sendOfferAsync(this.getMe(e));break;case"offer":await this.receiveOfferAsync(s,e);break;case"answer":await this.receiveAnswerAsync(s,e);break;case"done":this.receiveDone(s);break;case"candidate":this.receiveCandidate(s,new RTCIceCandidate(e.ice));break;case"bye":this.receiveBye(s);break;default:this.isDebug&&console.log(`Unknown message received!!! type=${e.type}`)}},this.getFrom=e=>{if(!e.from)throw new Error("Not occurring because from is set on the server side.");return e.from},this.getMe=e=>{if(!e.me)throw new Error("Not occurring because me is set on the caller.");return e.me},this.receiveUserDisconnected=e=>{this.isDebug&&console.log(`Receive user disconnected: ${e}`),this.closePc(e.id)},this.receiveConnectError=e=>{this.isDebug&&console.log(e.message),this.callbacks.onConnectFailed(e.message)},this.receiveDisconnect=e=>{this.isDebug&&console.log(e),this.callbacks.onDisconnected(e)},this.startHost=(e,s)=>{this.role=n.Host,this.getSocket().emit("create host",e,(e=>{this.isDebug&&console.log(e),s(e)}))},this.listHosts=e=>{this.getSocket().emit("list hosts",(s=>{this.isDebug&&console.log(s),e(s)}))},this.startClientAsync=async e=>{this.role=n.Client,this.hostId=e,this.sendMessage(e,{type:"join"})},this.sendOfferAsync=async e=>{this.pcMap.has(e)?this.isDebug&&console.log(`Send offer: Not sent as it already exists. to=${e}`):(await this.createPcAsync(e,!0),await this.handlePcAsync("sendOffer",e,(async s=>{const t=await s.createOffer();await s.setLocalDescription(t),this.sendSdp(e,s.localDescription)})))},this.stop=()=>{this.role=n.None,this.hostId=null;for(const e of this.pcMap.keys())this.sendMessage(e,{type:"bye"}),this.closePc(e);this.pcMap.clear(),this.clientState.clear(),this.stopSocket()},this.stopSocket=()=>{null!==this.socket&&(this.socket.close(),this.socket=null)},this.createPcAsync=async(e,t)=>{if(this.pcMap.has(e))return;const i=new RTCPeerConnection(this.peerConfig.pcConfig);i.onicecandidate=s=>{s.candidate&&(this.isDebug&&console.log(`Receive ice candidate: state=${s.candidate} id=${e}`),this.sendIce(e,s.candidate))},i.oniceconnectionstatechange=()=>{switch(this.isDebug&&console.log(`Receive ice connection change: state=${i.iceConnectionState} id=${e}`),i.iceConnectionState){case"new":case"checking":case"disconnected":break;case"connected":case"completed":this.role===n.Client&&this.clientState.finishIceCandidateGathering();break;case"failed":case"closed":this.closePc(e)}};for(const c of this.pcCreateHooks)s(c)?await c(e,t,i):c(e,t,i);this.pcMap.set(e,i)},this.closePc=e=>{this.handlePc("closePc",e,(s=>{this.pcCloseHooks.forEach((s=>s(e))),s.close(),this.pcMap.delete(e)}))},this.sendSdp=(e,s)=>{this.sendMessage(e,{type:s.type,sdp:s.sdp})},this.sendIce=(e,s)=>{this.handlePc("sendIce",e,(()=>this.sendMessage(e,{type:"candidate",ice:s})))},this.sendMessage=(e,s)=>{s.to=e,this.isDebug&&console.log(`Send message: ${JSON.stringify(s)}`),this.getSocket().emit("message",s)},this.receiveJoinAsync=async e=>{await this.sendOfferAsync(e);for(const s of this.pcMap.keys())e!==s&&this.sendMessage(s,{type:"call me",me:e})},this.receiveOfferAsync=async(e,s)=>{await this.createPcAsync(e,!1),await this.handlePcAsync("receiveOfferAsync",e,(async t=>{await t.setRemoteDescription(s),await this.sendAnswerAsync(e)}))},this.sendAnswerAsync=async e=>{await this.handlePcAsync("sendAnswerAsync",e,(async s=>{const t=await s.createAnswer();await s.setLocalDescription(t),this.sendSdp(e,s.localDescription)}))},this.receiveAnswerAsync=async(e,s)=>{await this.handlePcAsync("receiveAnswerAsync",e,(async t=>{await t.setRemoteDescription(s),this.sendMessage(e,{type:"done"})}))},this.receiveDone=e=>{this.role===n.Client&&e===this.hostId&&this.clientState.finishOfferAnswerProcess()},this.receiveCandidate=(e,s)=>{this.handlePc("receiveCandidate",e,(e=>e.addIceCandidate(s)))},this.receiveBye=e=>this.closePc(e),this.handlePc=(e,s,t)=>{const i=this.pcMap.get(s);if(i)try{t(i)}catch(s){this.logError(e,s)}},this.handlePcAsync=async(e,s,t)=>{const i=this.pcMap.get(s);if(i)try{await t(i)}catch(s){this.logError(e,s)}},this.logError=(e,s)=>{this.isDebug&&console.error(`Error has occurred at ${e}`,s)},this.socket=null,this.peerConfig=t,this.isDebug=t.isDebug,this.pcMap=new Map,this.pcCreateHooks=[],this.pcCloseHooks=[],this.clientState=new c(i.onStarted),this.callbacks=i,this.role=n.None,this.hostId=null}}class a{constructor(){this.adapt=()=>{t(this.withPrefix("WebGLPeerClient"),(e=>{const s=JSON.parse(e);s.isDebug&&console.log(s),this.peerClient=new o(s,{onStarted:()=>i(this.withPrefix("HandleOnStarted")),onConnectFailed:e=>i(this.withPrefix("HandleOnConnectFailed"),e),onDisconnected:e=>i(this.withPrefix("HandleOnDisconnected"),e)})})),t(this.withPrefix("DoStartHostAsync"),(e=>{this.getPeerClient().startHost(e,(e=>i(this.withPrefix("ReceiveStartHostResponse"),JSON.stringify(e))))})),t(this.withPrefix("DoListHostsAsync"),(()=>{this.getPeerClient().listHosts((e=>i(this.withPrefix("ReceiveListHostsResponse"),JSON.stringify(e))))})),t(this.withPrefix("DoStartClientAsync"),(async e=>await this.getPeerClient().startClientAsync(e))),t(this.withPrefix("DoStopAsync"),(()=>this.getPeerClient().stop()))},this.withPrefix=e=>`WebGLPeerClient#${e}`,this.getPeerClient=()=>{if(!this.peerClient)throw new Error("Call the WebGLPeerClient constructor first in Unity.");return this.peerClient}}}export{a as PeerAdapter,o as PeerClient,n as PeerRole};
