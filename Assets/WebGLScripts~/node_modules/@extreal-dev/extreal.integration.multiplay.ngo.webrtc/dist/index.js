import{waitUntil as t,addAction as e,callback as i}from"@extreal-dev/extreal.integration.web.common";import{PeerRole as s}from"@extreal-dev/extreal.integration.p2p.webrtc";class n{constructor(){this.strToNumMapping=new Map,this.numToStrMapping=new Map,this.add=t=>{const e=this.generate();this.strToNumMapping.set(t,e),this.numToStrMapping.set(e,t)},this.generate=()=>(new Date).getTime()+this.strToNumMapping.size,this.has=t=>Number.isFinite(t)?this.numToStrMapping.has(t):this.strToNumMapping.has(t),this.get=t=>Number.isFinite(t)?this.numToStrMapping.get(t):this.strToNumMapping.get(t),this.remove=t=>{if(!this.has(t))return;const e=this.strToNumMapping.get(t);this.strToNumMapping.delete(t),this.numToStrMapping.delete(e)},this.clear=()=>{this.strToNumMapping.clear(),this.numToStrMapping.clear()}}}class o{constructor(e,i,o){this.label="multiplay",this.createPc=(t,e,i)=>{if(!this.dcMap.has(t)&&(this.getPeerClient().role!==s.Client||t===this.getPeerClient().hostId))if(e){const e=i.createDataChannel(this.label);this.handleDc(t,e)}else i.addEventListener("datachannel",(e=>this.handleDc(t,e.channel)))},this.handleDc=(t,e)=>{if(e.label!==this.label)return;this.isDebug&&console.log(`New DataChannel: id=${t} label=${e.label}`),this.dcMap.set(t,e),this.idMapper.add(t);const i=this.idMapper.get(t);this.getPeerClient().role===s.Host&&e.addEventListener("open",(()=>{this.isDebug&&console.log(`OnOpen: clientId=${i}`),this.callbacks.onConnected(i)})),e.addEventListener("message",(t=>{this.callbacks.onDataReceived(i,t.data)})),e.addEventListener("close",(()=>{this.isDebug&&console.log(`OnClose: clientId=${i}`),this.getPeerClient().role===s.Host&&this.disconnectedRemoteClients.delete(i)||this.callbacks.onDisconnected(i)}))},this.closePc=t=>{const e=this.dcMap.get(t);e&&(e.close(),this.dcMap.delete(t),this.idMapper.remove(t))},this.connect=async()=>{if(this.isDebug&&console.log(`Connect: role=${this.getPeerClient().role}`),this.getPeerClient().role===s.Client){const e=this.getPeerClient().hostId;if(null===e)return;this.cancel=!1,await t((()=>this.idMapper.has(e)),(()=>this.cancel));const i=this.getHostId("connect",e);this.isHostIdNotFound(i)||this.callbacks.onConnected(i)}},this.hostIdNotFound=0,this.isHostIdNotFound=t=>t===this.hostIdNotFound,this.getHostId=(t,e)=>{let i;return i=null!==e&&this.idMapper.has(e)?this.idMapper.get(e):this.hostIdNotFound,this.isDebug&&console.log(`getHostId: caller=${t} hostId=${e}`),i},this.send=(t,e)=>{const i=t!==this.webRtcConfig.ngoServerClientId?t:this.getHostId("send",this.getPeerClient().hostId),s=this.idMapper.get(i);s?this.dcMap.get(s)?.send(e):this.isDebug&&console.log(`DoSend: id not found. clientId=${t}`)},this.clear=()=>{this.disconnectedRemoteClients.clear(),[...this.dcMap.keys()].forEach((t=>this.closePc(t))),this.dcMap.clear(),this.idMapper.clear(),this.cancel=!0},this.disconnectRemoteClient=t=>this.disconnectedRemoteClients.add(t),this.webRtcConfig=e,this.isDebug=e.isDebug,this.dcMap=new Map,this.idMapper=new n,this.disconnectedRemoteClients=new Set,this.getPeerClient=i,this.callbacks=o,this.cancel=!1,this.getPeerClient().addPcCreateHook(this.createPc),this.getPeerClient().addPcCloseHook(this.closePc)}}class h{constructor(){this.adapt=t=>{e(this.withPrefix("WebGLWebRtcClient"),(e=>{this.webRtcClient=new o(JSON.parse(e),t,{onConnected:t=>i(this.withPrefix("HandleOnConnected"),t.toString()),onDataReceived:(t,e)=>i(this.withPrefix("HandleOnDataReceived"),t.toString(),e),onDisconnected:t=>i(this.withPrefix("HandleOnDisconnected"),t.toString())})})),e(this.withPrefix("DoConnectAsync"),(()=>this.getWebRtcClient().connect())),e(this.withPrefix("DoSend"),((t,e)=>this.getWebRtcClient().send(Number(t),e))),e(this.withPrefix("DoClear"),(()=>this.getWebRtcClient().clear())),e(this.withPrefix("DisconnectRemoteClient"),(t=>this.getWebRtcClient().disconnectRemoteClient(Number(t))))},this.withPrefix=t=>`WebGLWebRtcClient#${t}`,this.getWebRtcClient=()=>{if(!this.webRtcClient)throw new Error("Call the WebGLWebRtcClient constructor first in Unity.");return this.webRtcClient}}}export{h as WebRtcAdapter};
